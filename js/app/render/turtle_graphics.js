// Turtle_graphics.js is a 3D LOGO-style "turtle" wrapper for three.js used
// for LSystem drawing.

// BUT ALSO LOOK AT THIS:
//http://www.akdillon.net/pages/classes/cs493/dillon_proj2_final/docs/lsys.html

// Turtle wrapper for three.js
function Turtle(sc, mat, rad) {//, loc, U, L, H) {
    // Call parent constructor
    THREE.Object3D.call(this);

    // Turtle stack used to save states
    this.stack = [];

    // Rate of turtle movement
    this.rate = 1;

    // Radius of drawn cylinder
    this.width = rad;

    // THREE.js stuff
    this.scene = sc;
    this.material = mat;

};
// Turtle inherits Object3D
Turtle.prototype = new THREE.Object3D();

// Correct constructor pointer
Turtle.prototype.constructor = Turtle;

/* Turtle actions */
// Move turtle forward, drawing a line
// TODO: WAAY too many objects created?
Turtle.prototype._F = function(time) {
    /* DRAW WITH THREE.js */
    // Create geometry
    // TODO: Taper width?
    var geo = new THREE.CylinderGeometry(this.width, this.width,
        time*this.rate);
    var mesh = new THREE.Mesh(geo, this.material);

    // Build initial transform matrix
    var mat_it = new THREE.Matrix4();
    mat_it.makeTranslation(0, 0, 0.5*this.rate*time);
    var mat_ir = new THREE.Matrix4();
    mat_ir.makeRotationFromEuler(new THREE.Euler(Math.PI / 2, 0, 0));
    var mat_is = new THREE.Matrix4();
    mat_is.makeScale(1,1,1);
    var mat_i = new THREE.Matrix4();
    mat_i.multiplyMatrices(mat_it, mat_ir);
    mat_i.multiply(mat_is);
    mesh.applyMatrix(mat_i);

    // Move in to position, assuming cylinder is oriented y+ w/ axis at center
    // Move into initial position
    //mesh.rotation.set(Math.PI / 2, 0, 0);

    // Get heading vector
    var heading = new THREE.Vector3(0,0,1);
    heading.applyEuler(this.rotation);

    // Build move matrix
    var mat_ft = new THREE.Matrix4();
    mat_ft.makeTranslation(this.position.x, this.position.y, this.position.z);
    var mat_fr = new THREE.Matrix4();
    mat_fr.makeRotationFromEuler(this.rotation);
    var mat_fs = new THREE.Matrix4();
    mat_fs.makeScale(1,1,1);
    var mat_f = new THREE.Matrix4();
    mat_f.multiplyMatrices(mat_ft, mat_fr);
    mat_f.multiply(mat_fs);
    mesh.applyMatrix(mat_f);

    scene.add(mesh);

    // Move turtle to new position
    this.position.add(heading.multiplyScalar(time*this.rate));

};
// Move turtle forward, not drawing a line
Turtle.prototype._f = function(time) {
    // Move turtle to new position
    var heading = new THREE.Vector3(0,0,1);
    heading.applyEuler(this.rotation);
    this.position.add(heading.multiplyScalar(time*this.rate));

};
// Rotate around the U axis ("up"), the local y axis
Turtle.prototype._yaw = function(deg) {
    this.rotation.y += deg;

};
// Rotate around the L axis ("left"), the local x axis
Turtle.prototype._pitch = function(deg) {
    this.rotation.x += deg;

};
// Rotate around the H axis ("heading"), the local z axis
Turtle.prototype._roll = function(deg) {
    this.rotation.z += deg;

};
// ?? Sets line width / diameter ??
Turtle.prototype._set = function(width) {
    this.width = width;

};
// Pushes state (object3d info) on to stack
Turtle.prototype._push = function() {
    // There's prob a better way but for now imma store values sue me
    var state = {position: this.position, rotation: this.rotation};
    this.stack.push(state);

};

// Pops state from stack
Turtle.prototype._pop = function() {
    var state = this.stack.pop();

    // ERROR: Stack empty
    if (state == null) {
        console.error('ERROR: Pop called on empty turtle stack!');
        return;

    }
    this.position = stack.position;
    this.rotation = stack.rotation;

};

/* Turtle methods */
// Takes a list of actions (generated by l-system, maybe?) and runs them
Turtle.prototype.run = function(actions) {
    // Actions are current free of context, use "call" to run them on this
    // instance
    for (var i = 0; i < actions.length; i++) {
        console.log(i);
        actions[i].f.call(this, actions[i].t);

    }
    // Consider resetting position?

};

// Holds an action and parameters. Not sure if this is the best way to do this
function Action(func, time) {
    this.f = func;
    this.t = time;

};
